<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Mashiro Flow Gallery</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .masonry-container { 
      display: flex; 
      gap: 12px; 
      width: 100%; 
      align-items: flex-start;
    }
    .masonry-column { 
      flex: 1; 
      display: flex; 
      flex-direction: column; 
      gap: 12px; 
      min-width: 0;
    }
    .masonry-item { 
      border-radius: 10px; 
      overflow: hidden; 
      background: #fff; 
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      /* 初始透明度，等图片加载后再显示，防止闪烁 */
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.2s;
    }
    .masonry-item.loaded { opacity: 1; }
    .masonry-item:hover { transform: translateY(-4px); }
    .masonry-item img { width: 100%; display: block; height: auto; }
    #sentinel { height: 80px; }
  </style>
</head>
<body class="bg-gray-50 text-gray-900">
  <section class="max-w-6xl mx-auto p-4">
    <header class="py-6"><h1 class="text-2xl font-bold">Gallery</h1></header>

    <div id="masonry" class="masonry-container"></div>
    <div id="sentinel"></div>
  </section>

  <script>
    const masonry = document.getElementById('masonry');
    const getColumnCount = () => window.innerWidth < 640 ? 2 : (window.innerWidth < 1024 ? 3 : 4);
    const columnCount = getColumnCount();
    const columns = [];
    let rawImageList = [];
    let displayQueue = [];

    // 初始化列
    for (let i = 0; i < columnCount; i++) {
      const col = document.createElement('div');
      col.className = 'masonry-column';
      masonry.appendChild(col);
      columns.push(col);
    }

    async function init() {
      try {
        const res = await fetch('./images.json');
        rawImageList = await res.json();
        refreshQueue();
        // 初始加载：为了防止不对称，我们需要一张一张顺序插入
        await loadMore(15); 
        setupObserver();
      } catch (err) { console.error(err); }
    }

    function refreshQueue() {
      displayQueue = [...rawImageList].sort(() => Math.random() - 0.5);
    }

    // 核心改进：等待图片预加载完成后再决定放入哪一列
    async function addSingleImage() {
      if (displayQueue.length === 0) refreshQueue();
      const fileName = displayQueue.shift();

      return new Promise((resolve) => {
        const img = new Image();
        img.src = `./img/${fileName}`;
        
        // 当图片元数据加载完成（能获取高度）时执行
        img.onload = () => {
          const item = document.createElement('div');
          item.className = 'masonry-item';
          
          const displayImg = document.createElement('img');
          displayImg.src = img.src;
          item.appendChild(displayImg);

          // 寻找当前最短的列
          const shortestCol = columns.reduce((prev, curr) => 
            prev.offsetHeight <= curr.offsetHeight ? prev : curr
          );
          
          shortestCol.appendChild(item);
          // 稍微延迟一点点让浏览器计算高度，并添加渐显动画
          requestAnimationFrame(() => {
            item.classList.add('loaded');
            resolve();
          });
        };

        // 如果图片加载失败，跳过这一张
        img.onerror = () => resolve();
      });
    }

    async function loadMore(count = 8) {
      // 使用 for 循环配合 await，确保一张接一张地计算高度并插入
      for (let i = 0; i < count; i++) {
        await addSingleImage();
      }
    }

    function setupObserver() {
      const observer = new IntersectionObserver(async (entries) => {
        if (entries[0].isIntersecting) {
          // 停止观察，防止连续触发
          observer.unobserve(entries[0].target);
          await loadMore(8);
          // 加载完后重新观察
          observer.observe(document.getElementById('sentinel'));
        }
      }, { rootMargin: '300px' });
      observer.observe(document.getElementById('sentinel'));
    }

    init();
  </script>
</body>
</html>