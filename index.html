<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>Mashiro Flow Gallery</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* 强制容器为 Flex 布局 */
    .masonry-container { 
      display: flex !important; 
      gap: 16px; 
      width: 100%; 
      align-items: flex-start;
    }
    /* 确保每一列平均分配宽度 */
    .masonry-column { 
      flex: 1; 
      display: flex; 
      flex-direction: column; 
      gap: 16px; 
      min-width: 0; /* 防止内容撑开列宽 */
    }
    .masonry-item { 
      border-radius: 12px; 
      overflow: hidden; 
      background: #fff; 
      box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1); 
      transition: transform 0.2s; 
    }
    .masonry-item:hover { transform: translateY(-4px); }
    .masonry-item img { 
      width: 100%; 
      display: block; 
      height: auto; 
      background: #f3f4f6; /* 占位背景色 */
    }
    #sentinel { height: 50px; margin-top: 20px; }
  </style>
</head>
<body class="bg-slate-50">
  <section class="max-w-6xl mx-auto p-4">
    <header class="py-8">
      <h1 class="text-3xl font-extrabold text-slate-800 tracking-tight">Mashiro Flow</h1>
    </header>

    <div id="masonry" class="masonry-container"></div>
    
    <div id="sentinel"></div>
  </section>

  <script>
    const masonry = document.getElementById('masonry');
    // 根据屏幕宽度决定列数：手机 2 列，平板 3 列，电脑 4 列
    const getColumnCount = () => {
      const width = window.innerWidth;
      if (width < 640) return 2;
      if (width < 1024) return 3;
      return 4;
    };

    const columnCount = getColumnCount();
    const columns = [];
    let rawImageList = [];
    let displayQueue = [];
    let globalIndex = 0; // 用于辅助均匀分配

    // 初始化列
    for (let i = 0; i < columnCount; i++) {
      const col = document.createElement('div');
      col.className = 'masonry-column';
      masonry.appendChild(col);
      columns.push(col);
    }

    async function init() {
      try {
        // 获取构建脚本生成的清单
        const res = await fetch('./images.json');
        if (!res.ok) throw new Error('Failed to load images.json');
        rawImageList = await res.json();
        
        refreshQueue();
        loadImages(12); // 初始加载 12 张
        setupObserver();
      } catch (err) {
        console.error("初始化失败:", err);
      }
    }

    function refreshQueue() {
      // 克隆并随机打乱
      displayQueue = [...rawImageList].sort(() => Math.random() - 0.5);
    }

    function loadImages(count = 8) {
      for (let i = 0; i < count; i++) {
        if (displayQueue.length === 0) {
          refreshQueue();
        }

        const fileName = displayQueue.shift();
        const item = document.createElement('div');
        item.className = 'masonry-item';
        
        const img = document.createElement('img');
        // 关键：为了防止缓存导致随机失效，可以不加后缀，或根据需要加
        img.src = `./img/${fileName}`;
        img.loading = 'lazy';
        
        item.appendChild(img);
        
        // 【核心修复】：不再依赖 offsetHeight，改用简单的取模分配
        // 这样可以保证即便图片没加载，也会均匀分布在各列
        columns[globalIndex % columnCount].appendChild(item);
        globalIndex++;
      }
    }

    function setupObserver() {
      const observer = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting) {
          loadImages(8);
        }
      }, { rootMargin: '400px' });
      
      observer.observe(document.getElementById('sentinel'));
    }

    // 启动
    init();
  </script>
</body>
</html>